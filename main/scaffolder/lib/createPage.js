const e = require("fs"), t = require("vm"), r = require("util"), a = require("ejs"), s = require("path"), n = require("uppercamelcase"), i = require("kebab-case"), o = require("semver"), c = require("mkdirp"), u = require("rimraf"), l = require("debug")("create-ice-page"), p = require("./utils"), d = require("./generateRouteFile"), g = require("./pageTemplates"), f = require("./config"), m = require("prettier"), h = require("./interactiveFileReplacement"), v = require("./errors/DependenciesError"), y = ["*", "404", "502"];
module.exports = 
async function (
    {pageName: a,
    routeName: o,
    routeIcon: u,
    destDir: l,
    layout: N,
    blocks: w = [],
    interpreter: j,
    commonBlock: x = !1,
    preview: S = !1,
    builtIn: E = !1}
) {
    let k = [];
    if (S && (a = "IceworksPreviewPage", o = "IceworksPreviewPage"), !await p.checkValidICEProject(l)) return p.createInterpreter("UNSUPPORTED_DESTPATH", {
        destDir: l
    }, j), [];
    const P = n(a || "");
    a = i(P || "").replace(/^-/, "");
    const I = s.join(l, "src/pages", P);
    if (E && e.existsSync(I) && e.readdirSync(I).length > 0) {
        if (!await p.createInterpreter("DESTDIR_EXISTS_OVERRIDE", {
            dir: I,
            destDir: l
        }, j)) return []
    }
    const q = s.join(l, "package.json"), $ = JSON.parse(e.readFileSync(q));
    $.dependencies = $.dependencies || {};
    const b = {};
    if (Array.isArray(w)) for (let e = 0; e < w.length; e++) {
        const t = w[e], {
            dependencies: r
        } = await p.getDependencies(t.npm, t.version);
        Object.keys(r).forEach(e => {
            const t = r[e];
            $.dependencies.hasOwnProperty(e) || (b[e] = t)
        })
    }
    if (Object.keys(b).length > 0) {
        if (!await p.createInterpreter("ADD_DEPENDENCIES", b, j)) {
            const e = w.map(e => `$ {
                e.npm
            }@$ {
                e.version
            }`).join(" "), t = Object.keys(b).map(e => `$ {
                e
            }@$ {
                b[e]
            }`).join(" ");
            throw new v("blocks \u5b89\u88c5\u5931\u8d25", {
                message: `\u65e0\u6cd5\u5b89\u88c5\u4ee5\u4e0b\u533a\u5757\uff1a\n blocks: $ {
                    e
                }\n dependencies: $ {
                    t
                }`
            })
        }
    }
    if (Array.isArray(w)) for (let e = 0; e < w.length; e++) {
        const t = w[e], r = await p.getTarballURL(t.npm, t.version), a = t.alias || t.name, i = n(a);
        let o = "src/components";
        t.className = i, t.relativePath = `../../components/$ {
            i
        }`, S ? (t.relativePath = `./blocks/$ {
            i
        }`, o = "src/pages/IceworksPreviewPage/blocks") : (x || t.common) && (t.relativePath = `./components/$ {
            i
        }`, o = `src/pages/$ {
            P
        }
        /components`);
        const c = await p.extractBlock(s.join(l, o, i), r, l);
        k = k.concat(c)
        }
        const D = {
            layout: N,
            blocks: w,
            className: P,
            pageName: a
        };
        if (!e.existsSync(s.join(l, "src/layouts", N))) {
            const e = n(N), t = `@icedesign/$ {
                i(e).replace(/^-/, "")
            }`, r = await p.getTarballURL(t), {
                dependencies: a
            } = await p.getDependencies(t), o = {};
            Object.keys(a).forEach(e => {
                const t = a[e];
                $.dependencies.hasOwnProperty(e) || (o[e] = t)
            }), (await p.extractBlock(s.join(l, "src/layouts ", e), r, l)).forEach(e => k.push(e))
        }
        c.sync(I);
        const O = g.reduce((t, r) => {
            try {
                const a = m.format(r.compile(D), f.prettier), n = r.fileName.replace(/PAGE/g, P).replace(/\.ejs$/g, ""), i = s.join(I, n);
                return k.push(i), e.writeFileSync(i, a, "utf - 8 "), 1 & t
            } catch (e) {
                return 0 & t
            }
        }, 1), A = s.join(l, "generator.json "), R = JSON.parse(e.readFileSync(A, "utf - 8 ")); - 1 === R.routes.findIndex(e => e.path === o) ? R.routes.push({
            page: n(a),
            path: o,
            layout: N
        }) : R.routes = R.routes.map(e => e.path === o ? {
            page: n(a),
            path: o,
            layout: N
        } : e), e.writeFileSync(A, JSON.stringify(R, null, 2) + "\n ");
        const F = s.join(l, "src/routes.jsx "), G = new h({
            file: F,
            tagPrefix: " // \x3c!-- auto generated routes start --\x3e",
            tagSuffix: "// \x3c!-- auto generated routes end --\x3e"
        }), {
            imports: T,
            routes: _
        } = await d(l, R.routes), C = m.format(`$ {
            T
        }\nconst autoGeneratedRoutes = $ {
            _
        };`, f.prettier);
        G.replace(C);
        let H, J = "", L = !1;
        const U = s.join(l, "src/config/navs.json");
        e.existsSync(U) && (J = U, L = !0), L || (J = s.join(l, "src/navs.js"), H = new h({
            file: J,
            tagPrefix: "// \x3c!-- auto generated navs start --\x3e",
            tagSuffix: "// \x3c!-- auto generated navs end --\x3e"
        }));
        const B = e.readFileSync(J);
        let V;
        if (L) try {
            V = JSON.parse(B)
        } catch (e) {
            V = {
                headerNavs: [],
                asideNavs: []
            }
        } else {
            const e = H.getFileContent(), r = {};
            t.createContext(r);
            try {
                t.runInContext(`$ {
                    e
                }\nvar result = {
                    autoGenHeaderNavs, autoGenAsideNavs
                };`, r)
            } catch (e) {
                r.result = {}
            }
            V = {
                headerNavs: r.result.autoGenHeaderNavs || [],
                asideNavs: r.result.autoGenAsideNavs || []
            }
        }
        if (!S && !E) {
            const e = o.startsWith("/"), t = e ? o.substr(1) : o, r = e ? o : `/$ {
                o
            }`, a = V.asideNavs.some(e => e.to === r), s = V.headerNavs.some(e => e.to === r), n = {
                text: t,
                to: r,
                icon: u || "nav-list"
            };
            t && !s && (a ? V.asideNavs = V.asideNavs.map(e => e.to === r ? n : e) : y.indexOf(o) > -1 || V.asideNavs.push(n))
        }
        return L ? e.writeFileSync(J, JSON.stringify(V, null, 2)) : H.replace(m.format(`\n const autoGenHeaderNavs = $ {
            r.inspect(V.headerNavs, {
                showHidden: !1,
                depth: null
            })
        };\n\n const autoGenAsideNavs = $ {
            r.inspect(V.asideNavs, {
                showHidden: !1,
                depth: null
            })
        };\n`), f.prettier), k.push(F), O ? await p.createInterpreter("FILE_CREATED", k, j) : await p.createInterpreter("RENDER_PAGE_FAIL", !0, j), k};
